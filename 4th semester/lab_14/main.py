d = 256 # число символов алфавита

def search(pat, txt, q):
	M = len(pat)
	N = len(txt)
	p = 0 # хеш значение для паттерна
	t = 0 # хеш значение для текста
	h = 1

	# значение h станет "pow(d, M-1)%q"
	for i in range(M-1):
		h = (h*d) % q

	# вычисление хэш-значения шаблона и первого окна текста
	for i in range(M):
		p = (d*p + ord(pat[i])) % q
		t = (d*t + ord(txt[i])) % q

	# передвигаем шаблон по тексту
	for i in range(N-M+1):
		# Проверяем хэш-значения текущего окна текста и
        # шаблона, если хэш-значения совпадают, тогда проверяем
        # символы по одному
		if p == t:
			# проверяем символы по одному
			for j in range(M):
				if txt[i+j] != pat[j]:
					break
				else:
					j += 1

			# если p == t и pat[0...M-1] = txt[i, i+1, ...i+M-1]
			if j == M:
				print("Pattern found at index " + str(i))

		# Вычисляем хэш-значение для следующего окна текста: убираем
        # ведущий символ, добавляем завершающий символ
		if i < N-M:
			t = (d*(t-ord(txt[i])*h) + ord(txt[i+M])) % q

			# Мы можем получить отрицательные значения t, приводим их к
            # положительным
			if t < 0:
				t = t+q


if __name__ == '__main__':
	txt = "ABAAABCD"
	pat = "ABC"

	q = 101 # простое число

	search(pat, txt, q)
